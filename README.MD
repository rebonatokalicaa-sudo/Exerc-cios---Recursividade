# ğŸ§  ExercÃ­cios de Recursividade em Python

Este projeto contÃ©m cinco desafios sobre **funÃ§Ãµes e recursividade**, desenvolvidos para treinar lÃ³gica, uso de escopo, retorno de valores e comparaÃ§Ã£o entre abordagens recursivas e iterativas.  
Os cÃ³digos foram feitos de forma simples e didÃ¡tica, para facilitar o entendimento dos conceitos.

---

## ğŸ“˜ Desafio 1 â€“ FunÃ§Ã£o com mÃºltiplos retornos e escopo

### ğŸ“ Enunciado:
Crie uma funÃ§Ã£o `analisar_numeros(lista)` que:
- Retorne trÃªs valores: quantidade de positivos, negativos e zeros.  
- Teste o comportamento ao usar uma **variÃ¡vel global** chamada `total_elementos` e mostre como o escopo interfere no resultado.  
- **Desafio extra:** reescreva sem variÃ¡vel global, usando apenas parÃ¢metros e retornos.

### ğŸ’¡ SoluÃ§Ã£o:
Foi criada uma funÃ§Ã£o que percorre a lista e conta quantos valores sÃ£o positivos, negativos ou zeros.  
Na primeira versÃ£o, uma variÃ¡vel global controla o total de elementos.  
Na segunda, o total Ã© retornado diretamente, evitando o uso de variÃ¡veis globais.

---

## ğŸ” Desafio 2 â€“ Soma Recursiva

### ğŸ“ Enunciado:
Implemente uma funÃ§Ã£o recursiva `soma_lista(lista)` que some todos os elementos de uma lista numÃ©rica.  
**Exemplo:** `soma_lista([1, 2, 3, 4]) â†’ 10`

### ğŸ’¡ SoluÃ§Ã£o:
A funÃ§Ã£o chama a si mesma retirando o primeiro elemento da lista a cada passo.  
Quando a lista fica vazia, retorna 0.  
Essa estrutura garante a soma de todos os valores de forma recursiva.

---

## ğŸ” Desafio 3 â€“ RecursÃ£o com Retorno Condicional

### ğŸ“ Enunciado:
Crie uma funÃ§Ã£o `buscar_maior(lista)` que:
- Retorne o **maior nÃºmero** da lista usando recursÃ£o (sem usar `max()`).
- Mostre no `print` cada comparaÃ§Ã£o feita.

### ğŸ’¡ SoluÃ§Ã£o:
A funÃ§Ã£o compara o primeiro elemento da lista com o maior encontrado no restante (obtido recursivamente).  
Cada comparaÃ§Ã£o Ã© exibida no terminal, mostrando o processo passo a passo atÃ© encontrar o maior valor.

---

## ğŸ§® Desafio 4 â€“ SequÃªncia de Fibonacci (Recursiva e Iterativa)

### ğŸ“ Enunciado:
Crie duas funÃ§Ãµes:
- `fibonacci_recursivo(n)`  
- `fibonacci_iterativo(n)`  
Mostre a diferenÃ§a de performance entre as duas, exibindo o tempo total de execuÃ§Ã£o.

### ğŸ’¡ SoluÃ§Ã£o:
O mÃ©todo recursivo chama a si mesmo para calcular `f(n-1)` e `f(n-2)`, o que Ã© mais lento.  
O mÃ©todo iterativo usa um `for`, sendo muito mais rÃ¡pido.  
Foi utilizado o mÃ³dulo `time` para medir e exibir o tempo de execuÃ§Ã£o.

---

## ğŸ“¦ Desafio 5 â€“ Controle de Estoque Recursivo

### ğŸ“ Enunciado:
Desenvolva uma simulaÃ§Ã£o para controle de estoque recursivo:  
Cada produto tem **nome** e **quantidade**.  
A funÃ§Ã£o `verificar_estoque(lista, indice=0)` percorre recursivamente a lista e retorna a soma total das quantidades.  
Exibir mensagens como:  
